List 인터페이스는 순서가 있는 데이터의 집합이며, 데이터의 중복을 허용한다.
구현 클래스로는 ArrayList, LinkedList, Stack, Vector 등이 있다.

List 인터페이스는 Collection의 다른 인터페이스들과 가장 큰 차이는 배열처럼 순서가 있다는 것이다.
List 컬렉션은 객체를 일렬로 늘어놓은 구조를 가지고 있다.
객체를 인덱스로 관리하기 때문에 객체를 저장하면
자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다.

List 컬렉션은 객체 자체를 저장하는 것이 아니라 객체의 번지를 참조한다.
즉, 인덱스마다 객체의 번지 주소가 들어있다. 동일한 객체를 중복 저장할 수 있는데,
이 경우 동일한 번지가 참조되고 null이 저장될 경우에는 해당 인덱스는 객체를 참조하지 않는다.

■ Vector
List<E> list = new Vector<E>();
ArrayList와 같은 동작을 수행하는 클래스이다.
하지만 현재에는 기존 코드와의 호환성을 위해서만 남아있으므로 Vector 클래스 보다는 ArrayList 클래스를 사용하는 것이 좋다.

특히 쓰레드의 개수와 상관없이 동기화 처리를 하므로 Thread-safe 하지만 싱글쓰레드 환경이어도 동기화 처리를 하므로 성능이 좋지 않아 잘 쓰이지 않는다.

ArrayList와 다른점은 Vector은 동기화된 메서드로 구성되어 있기 때문에 멀티스레드가 동시에 이 메서드들을 실행할 수가 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드가 실행할 수 있다.
그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다.

■ ArrayList
List<String> list = new ArrayList<String>(30);

ArrayList는 List 인터페이스의 구현 클래스로, 컬렉션 프레임뭑에서 가장 많이 사용되는 컬렉션 클래스일 것이다.
ArrayList에 객체를 추가하면 객체가 인덱스로 관리된다. 일반배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서는 유사하지만, 큰 차이점을 가지고 있다. 

ArrayList는 Object 배열을 이용해서 데이터를 순차적으로 저장하게 되는데 배열에 더 이상 저장할 공간이
없으면 보다 큰 새로운 배열을 생성해 기존의 배열에 저장된 새로운 배열을 복사한 다음에 저장한다.

즉, 배열은 생성할 때 크기가 고정되고, 사용 중에 크기를 변경할 수 없지만, ArrayList는 저장 용량을 초과한 객체들이 들어오면 자동적으로 저장 용량이 늘어난다는 것이다.

ArrayList는 Vector과 같은 추가/삭제 기능을 가지고 있고 자동 동기화 처리가 되지 않기 때문에 빠르게 처리가 가능하다.

대신 내부적으로 배열 구조를 이용한다고 하였다.
이러한 특징으로 데이터 추가/제거를 배열을 복사하는 방법으로 처리하기 때문에 추가/제거가 많을 경우 오버헤드가 많이 발생한다. 특히 중간에 삽입될 때 데이터들이 뒤로 밀리면서 성능이 저하된다.
대신 인덱스를 가지고 있어서 조회할 때 한 번에 접근이 가능하기 때문에 대용량 데이터를 한 번에 가져와서
여러번 참조하여 사용할 때는 최상의 성능을 내는 객체이다.

동기화처리가 되는 컬렉션을 생성하면 멀티쓰레드 환경에서 쓸 수 있다.

■LinkedList
LinkedList는 List 구현 클래스이므로 ArrayList와 사용방법은 같지만 내부 구조는 완전 다르다.
ArrayList는 내부 배열 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 
체인처럼 관리한다.

연결된 자료의 정보만 담고 있기 때문에 중간 노드에 추가/삭제시 다른데이터의 위치를 변경시킬 필요없이 간단하게 추가/삭제할 수 있다.
따라서 추가/삭제가 빈번하게 일어나는 대용량 데이터 처리가 필요할 때 사용하면 성능이 좋다.
대신 찾고자 하는 참조가 어디에 있던, 첫번째 노드부터 순차적으로 찾아가야하므로, 검색에 있어서 성능이 좋지 않다.

스택, 큐, 양방향 큐를 만들 때 사용한다.
